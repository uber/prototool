# gRPC

The `prototool grpc` command calls a gRPC endpoint using a JSON input. What this does behind the scenes:

- Compiles your Protobuf files with `protoc`, generating a `FileDescriptorSet`.
- Uses the `FileDescriptorSet` to figure out the request and response type for the endpoint, and to convert the JSON input to binary.
- Calls the gRPC endpoint.
- Uses the `FileDescriptorSet` to convert the resulting binary back to JSON, and prints it out for you.

All these steps take on the order of milliseconds, for example the overhead for a file with four dependencies is about 30ms, so there is little overhead for CLI calls to gRPC.

There is a full example for gRPC in the [example](../example) directory. Run `make example` to make sure everything is installed and generated.

Start the example server in a separate terminal by doing `go run example/cmd/excited/main.go`.

`prototool grpc [dirOrFile] --address serverAddress --method package.service/Method --data 'requestData'`

Either use `--data 'requestData'` as the the JSON data to input, or `--stdin` which will result in the input being read from stdin as JSON.

```bash
$ make example # make sure everything is built just in case
$ go run example/cmd/excited/main.go # run in another terminal

$ prototool grpc example \
  --address 0.0.0.0:8080 \
  --method uber.foo.v1.ExcitedAPI/Exclamation \
  --data '{"value":"hello"}'
{"value": "hello!"}

$ prototool grpc example \
  --address 0.0.0.0:8080 \
  --method uber.foo.v1.ExcitedAPI/ExclamationServerStream \
  --data '{"value":"hello"}'
{"value": "h"}
{"value": "e"}
{"value": "l"}
{"value": "l"}
{"value": "o"}
{"value": "!"}

$ cat input.json
{"value":"hello"}
{"value":"salutations"}

$ cat input.json | prototool grpc example \
  --address 0.0.0.0:8080 \
  --method uber.foo.v1.ExcitedAPI/ExclamationClientStream \
  --stdin
{"value": "hellosalutations!"}

$ cat input.json | prototool grpc example \
  --address 0.0.0.0:8080 \
  --method uber.foo.v1.ExcitedAPI/ExclamationBidiStream \
  --stdin
{"value": "hello!"}
{"value": "salutations!"}

$ prototool grpc example \
  --address 0.0.0.0:8080 \
  --method uber.foo.v1.ExcitedAPI/ExclamationServerStream \
  --data '{"value":"hello"}' \
  --details
{"headers":{"content-type":["application/grpc"]}}
{"response":{"value":"h"}}
{"response":{"value":"e"}}
{"response":{"value":"l"}}
{"response":{"value":"l"}}
{"response":{"value":"o"}}
{"response":{"value":"!"}}
```

## SSL/TLS Connections

To enable SSL/TLS connections to the server, use the `--tls` command line flag.

If not specified, setting any of the following flags will produce an error.

### curl style TLS/SSL flags

The following flags mirror the flags of the same names from from the `curl` command line tool

For more detailed information see:
https://curl.haxx.se/docs/manpage.html

By default host validation is enabled. To disable, pass the `--insecure` command line flag. If using this tool in any
form of production-like setting, it is HIGHLY recommended not to use the `--insecure` flag as it allows for multiple
network exploits.

If `--insecure` is specified, setting any of the following flags will produce an error.

If the certificate presented by the server is not generated by a system trusted CA, you must also set the `--cacert` 
flag to a pem encoded file of the CA public certificate that generated the server certificate or the server public  
certificate itself. The cacert file may contain multiple certificates or certificate authorities appended together 
(new line separated).  You must also include any intermediary certificates if required to validate the server 
certificate against the given CA certificate (generally only true in commercially generated certificates, 
not self signed ones).

By default, the "Common Name" (and any "Subject Alternative Names") will be used to validate the authenticity of the 
server connection based upon the `--address` specified.  If your server certificate's common name does not match the 
address you are accessing it from (for example, if your address is an IP address), pass `--server-name` command line 
flag with the value expected in the "Common Name" field of the server certificate.  

To use mutual SSL/TLS with a client key and certificate, pass the `--key` and `--cert` command line flag to the path of 
the files in pem format. If one is specified the other must also be specified. Unlike curl, you cannot pass a file with
the key and cert concatenated together as the `--cert` flag. Also unlike curl, you cannot pass the `-E` flag as an alias
for the `--cert` flag.

```bash
$ prototool grpc example \  
  --data '{"value":"hello"}'
  --address 192.168.1.15:443
  --method uber.foo.v1.ExcitedAPI/Exclamation
  --tls
  --cacert ./server.crt
  --cert ./client.crt
  --key ./client.key
  --server-name foo.bar.com
```
